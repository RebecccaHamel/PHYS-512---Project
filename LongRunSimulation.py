# -*- coding: utf-8 -*-
"""Working 512_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fSY3mkfLbBhIrtSrhNdtKu6PQT4k7TMv
"""

import numpy as np
import pandas as pd

######### INITIAL CONDITIONS AND CONSTANTS #####################
au_to_m=1.49597870700e11 # https://en.wikipedia.org/wiki/Astronomical_unit
G=6.67430e-11 # https://physics.nist.gov/cgi-bin/cuu/Value?bg (in SI units: m^3 kg^{-1} s)
pi=np.pi
deg_to_rad=pi/180.0
years_to_s = 31536000
perihelion_conversion = 1e6 * 1000

# SolarSysMass,SolarSysDist,SolarSysLong,SolarSysPeriod,SolarSysv0,SolarSysEcc,SolarSysPer=np.genfromtxt('sample_data/planet_data.csv',delimiter=',',dtype=np.float64)
SolarSysMass,SolarSysDist,SolarSysLong,SolarSysPeriod,SolarSysv0,SolarSysEcc,SolarSysPer=np.genfromtxt('planet_data.csv',delimiter=',')
SolarSysDist   *= au_to_m
SolarSysLong   *= deg_to_rad
SolarSysPeriod *= years_to_s
SolarSysPer    *= perihelion_conversion

#Calculation of other quantities and fixing nans.
SolarSysAph    = np.sqrt(SolarSysPer**2/(1 - SolarSysEcc**2)) # aphelion = semimajor axis
SolarSysR      = (SolarSysDist*(1-SolarSysEcc**2))/(1+SolarSysEcc*np.cos(SolarSysLong)) # account for elliptical orbits
SolarSysR[0] = 1
SolarSysDist[0] = 1
SolarSysV      = np.sqrt((G*SolarSysMass[0])*(2/SolarSysR - 1/SolarSysDist)) # likewise for velocity
################################################

###############################################################
#Create CSV to save simulation data
def checkpointSave(t0, tf, H, VEC, name, timeOffsetCounter):
    total_time = np.arange(t0 + H*timeOffsetCounter, tf + H*timeOffsetCounter, H)
    VEC_reshaped = VEC.reshape(VEC.shape[0], VEC.shape[1]*VEC.shape[2])
    time_list = total_time[:VEC_reshaped.shape[0]]

    planets = ['Sun','Mercury','Venus','Earth','Mars','Jupiter','Saturn','Uranus','Neptune']
    params = ['x', 'y', 'vx', 'vy']
    column_names = ['Time']
    for calculation in params:
        for planet in planets:
            column_names.append(planet + '_' + calculation)

    data = np.column_stack((time_list, VEC_reshaped))  # Combine time and reshaped Y
    simulation_data = pd.DataFrame(data, columns=column_names)
    simulation_data.to_csv(f'{name}.csv', index=True)
#################################################################

def get_pairwise_pos(r):
    '''
    calculate the (pairwise) position between all the bodies
    pass a 1D vector, get a 2D array out
    '''
    pairwise_r = np.subtract.outer(r,r)
    bodies_r   = np.sum(pairwise_r, axis=1)
    return pairwise_r, bodies_r

def get_pairwise_acc(pairwise_x, pairwise_y, masses, G = 6.67430e-11):
    '''
    Calculate the acceleration between all the bodies as store it in a 2D array.
    Also calculate the TOTAL acceleration on each body
    We use the convention that Rij means the acceleration ON mass i DUE TO mass j.
    '''

    pairwise_dists=np.sqrt(pairwise_x**2+pairwise_y**2)
    np.fill_diagonal(pairwise_dists,-np.inf)
    pairwise_acc = -G * masses / pairwise_dists**3
    np.fill_diagonal(pairwise_acc,np.float64(0))

    bodies_acc_x = np.sum(pairwise_acc*pairwise_x,axis=1)
    bodies_acc_y = np.sum(pairwise_acc*pairwise_y,axis=1)
    return bodies_acc_x, bodies_acc_y

# The basic unit of kinematic information in this code is the set of values
# [x,y,vx,vy] for each body. We concatenate these into 4 x nbodies array that
# encodes kinematic information for all bodies at one moment in time. For
# simplicity, in this code we'll call it vec, and its first time derivative
# dvecdt. By the time we form an array of kinematic information at different
# times, we've already summed over the pairwise information, so the time array
# will be 4 x nbodies x nsteps. We'll call this version VEC.

### MULTIPURPOSE DOCSTRING ###
# vec, [vec0] = vec at a particular moment in time (see above for details)
# dvecdt      = first time derivative of vec (see above) at one moment in time
# t0, tf      = initial/final time (of the integration or a particular step)
# masses      = 1 x nbodies array of the masses of the bodies
# H, [H0]     = full (not subdivided!) timestep at one step in time
### ARGUMENTS NOT DISCUSSED HERE APPEAR IN THEIR RESPECTIVE FUNCTIONS ###

def mmid(vec0, t0, tf, nss, masses):
    ''' take one modified midpoint step
    reference: Numerical Recipes
    nss         = number of substeps
    '''
    vec_prev=vec0
    H=tf-t0
    h=H/nss
    vec_curr=vec_prev+h*deriv(t0,vec_prev,masses)
    for m in range(1,nss):
        vec_next=vec_prev+2*h*deriv(t0,vec_curr,masses)
        vec_prev=vec_curr
        vec_curr=vec_next
    vec_new=0.5*(vec_prev+vec_curr+h*deriv(t0+H, vec_next, masses)) # beyond the previous, current, and next vecs, we don't need to store vec ... better this shuffling than a huge array
    return vec_new

def ratextrap(vec,t0,H0,masses,stsc=2,tol=1,maxiter=75):
    ''' Richardson rational function extrapolation
    references: Numerical Recipes, https://en.wikipedia.org/wiki/Richardson_extrapolation instead
    stsc    = step size scale factor
    tol     = how converged we require the extrapolation to be (fallback value as implemented on Wikipedia)
    maxiter = maximum number of extrapolation iterations (fallback value as implemented on Wikipedia)
    '''
    neqns,nbodies = vec.shape
    h             = H0
    A             = np.zeros((maxiter,maxiter,neqns,nbodies)) # to hold Richardson extrapolates ... the maxiter x maxiter slices will end up being lower triangular
    nss           = 2                                         # start with two substeps ... if it's not good enough, eval will try again with more
    A[0,0,:,:]    = mmid(vec,t0,t0+h,nss,masses)
    for i in range(1,maxiter): # start looping in row 1 b/c 0 is already populated
        A[i,0,:,:] = mmid(vec, t0, t0+nss*h, nss, masses) # still ok to call w/ vec b/c we're still dealing with the same step
        h/=2
        nss*=2
        for j in range(1,i+1):
            A[i,j,:,:]=((stsc)**(j)*A[i,j-1,:,:]-A[i-1,j-1,:,:])/((stsc)**(j)-1)
        EstErr=np.abs(A[i,i,:,:]-A[i-1,i-1,:,:])
        EstError = np.sqrt(np.sum((A[i,i,:,:] - A[i-1,i-1,:,:])**2)/4)
        if np.all(EstErr<tol):
            
            break # can be done iterating b/c the current eval is good enough
    assert(np.all(EstErr<tol)), 'try again with a higher limit on the number of substep doublings' # don't want to get away with unconverged errors
    return A[i,i,:,:],EstErr

def BulirschStoer(t0, vec, tf, H, masses, tol=1.0):
    '''
    Bulirsch-Stoer driver function
    reference: Numerical Recipes
    '''
    neqns,nbodies = vec.shape
    nstep=int((tf-t0)/H)

    #Stores time and planet data.
    T = np.arange(t0,tf,H)
    R = np.zeros((nstep,neqns,nbodies))
    R[0,:,:] = vec

    for i in range(1,nstep):
        #Iteration tracker
        if (i%100==0):
            print('Iteration', i)
        R[i,:,:],err=ratextrap(R[i-1,:,:], t0, H, masses)
        #Data checkpointing every 5000 iterations.
        if (i%5000 == 0):
            name = 'SolarSystemSimulationCheckpoint' + str(i//5000)
            checkpointSave(t0, tf, H, R[i-5000:i, :, :], name, 5000*((i-1)//5000))
            print(f'Checkpoint {i/5000} Saved')
    return T,R

def deriv(t0, vec, masses):
    '''
    coupled first-order recasting of Newton's Law of gravity for a 2D system:
    given a 4 x nbodies array of kinematic information about the system
    (where each column has the format [x,y,vx,vy].T),
    calculate the accelerations (you end up recalculating the velocities, too),
    so that the output/RHS has the format [vx,vy,ax,ay]
    '''
    rx,ry,vx,vy=vec
    pwx,bx    = get_pairwise_pos(rx)
    pwy,by    = get_pairwise_pos(ry)
    ax,ay = get_pairwise_acc(pwx,pwy,masses)
    dvecdt = np.vstack((vx, vy, ax, ay))
    return dvecdt


#Initial conditions of the ellipse.
x = SolarSysR * np.cos(SolarSysLong)
y = SolarSysR * np.sin(SolarSysLong)
v = SolarSysV

vx = -v * np.sin(SolarSysLong)  # Adjust to tangential direction
vy = v * np.cos(SolarSysLong)
vx[0] = 0  # Sun doesn't move
vy[0] = 0


#####USE THIS IF YOU WANT TO CONTINUE A LAST CHECKPOINT#########
#Remember to edit the checkpoint name
continueRun=True
if continueRun == True:
    checkpoint_df = pd.read_csv('SolarSystemSimulationCheckpointPrevious.csv')
    x = checkpoint_df[['Sun_x','Mercury_x','Venus_x','Earth_x','Mars_x','Jupiter_x','Saturn_x','Uranus_x','Neptune_x']].to_numpy()
    y = checkpoint_df[['Sun_y','Mercury_y','Venus_y','Earth_y','Mars_y','Jupiter_y','Saturn_y','Uranus_y','Neptune_y']].to_numpy()
    vx = checkpoint_df[['Sun_vx','Mercury_vx','Venus_vx','Earth_vx','Mars_vx','Jupiter_vx','Saturn_vx','Uranus_vx','Neptune_vx']].to_numpy()
    vy = checkpoint_df[['Sun_vy','Mercury_vy','Venus_vy','Earth_vy','Mars_vy','Jupiter_vy','Saturn_vy','Uranus_vy','Neptune_vy']].to_numpy()

    x = x[-1, :]
    y = y[-1, :]
    vx = vx[-1, :]
    vy = vy[-1, :]

vec0 = np.array([x, y, vx, vy])
freq = 1

#STEP SIZES AND TIMING
##################
H = 86400*13.5 #2 weeks
t0 = 0.0
tf = 5e6*H #Arbitrarily large so it just keeps running until I turn it off. 5e6 steps.
#################

T, VEC = BulirschStoer(t0, vec0, tf, H, SolarSysMass)
checkpointSave(t0, tf, H, VEC, 'SolarSystemSimulationLongRun', 0)

print('Simulation complete.')